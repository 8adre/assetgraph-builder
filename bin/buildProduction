#!/usr/bin/env node

var _ = require('underscore'),
    AssetGraph = require('assetgraph'),
    transforms = require('../lib/transforms'),
    query = AssetGraph.query,
    urlTools = require('assetgraph/lib/util/urlTools'),
    commandLineOptions = require('optimist').
        usage('$0 --root <inputRootDirectory> [--label <labelName>=<dir> ...] --outroot <dir> [--deferscripts] [--asyncscripts] [--locale <localeId>,...] [--cdnroot <url>] [--cdnoutroot <dir>] [--manifest] [--nocompress] [--mangletoplevel] <htmlFile>...').
        boolean('manifest', 'mangletoplevel').
        demand(['root', 'outroot']).
        argv,
    outroot = urlTools.fsDirToFileUrl(commandLineOptions.outroot),
    cdnroot = commandLineOptions.cdnroot && urlTools.ensureTrailingSlash(commandLineOptions.cdnroot),
    cdnoutroot = urlTools.fsDirToFileUrl(commandLineOptions.cdnoutroot),
    localeIds = commandLineOptions.locale && _.flatten(_.flatten([commandLineOptions.locale]).map(function (localeId) {return localeId.split(",");}));

new AssetGraph({root: commandLineOptions.root}).on('afterTransform', function (transform, elapsedTime) {
    console.log((elapsedTime / 1000).toFixed(3) + " secs: " + transform.name);
}).on('error', function (err) {
    console.error(err.stack);
    process.exit(1);
}).queue(
    transforms.registerLabelsAsCustomProtocols(commandLineOptions.label),
    transforms.loadAssets(commandLineOptions._.map(urlTools.fsFilePathToFileUrl)),
    transforms.populate({
        followRelations: query.or({to: {type: 'I18n'}},
                                  {type: 'HtmlAnchor', to: {type: query.not('Html'), url: query.not(/^https?:/)}},
                                  {type: query.not(['JavaScriptOneInclude', 'JavaScriptExtJsRequire', 'JavaScriptCommonJsRequire', 'HtmlAnchor']), to: {url: query.not(/^https?:/)}})
    }),
    localeIds && transforms.stripDevelopmentModeFromOneBootstrapper({type: 'Html', isInitial: true}),
    transforms.removeRelations({type: 'JavaScriptOneInclude', to: {type: ['Css', 'JavaScript']}}, {detach: true, unresolved: true}),
    transforms.inlineRelations({type: 'JavaScriptOneGetText'}),
    transforms.removeRelations({type: 'JavaScriptOneGetText'}, {removeOrphan: true}),
    transforms.convertCssImportsToHtmlStyles(),
    transforms.removeAssets({isEmpty: true, type: ['Css', 'JavaScript']}, true),
    transforms.externalizeRelations({from: {type: query.not('Htc')}, type: ['HtmlStyle', 'HtmlScript'], node: function (node) {return !node.hasAttribute('nobundle');}}),
    transforms.mergeIdenticalAssets(query.or({isImage: true}, {type: ['JavaScript', 'Css']})),
    require('assetgraph-sprite')(),
    transforms.postProcessCssImages(),
    transforms.bundleRequireJs({type: 'Html'}),
    transforms.minifyAssets({type: 'KnockoutJsTemplate'}),
    transforms.bundleRelations({type: ['HtmlStyle', 'HtmlScript'], node: function (node) {return !node.hasAttribute('nobundle');}}),
    function removeNobundleAttribute(assetGraph) {
        assetGraph.findRelations({type: ['HtmlScript', 'HtmlStyle']}).forEach(function (relation) {
            if (relation.node.hasAttribute('nobundle')) {
                relation.node.removeAttribute('nobundle');
                relation.from.markDirty();
            }
        });
    },
    transforms.inlineCssImagesWithLegacyFallback({type: 'Html', isInline: false}, 8192),
    commandLineOptions.mangletoplevel && transforms.pullGlobalsIntoVariables({type: 'JavaScript'}),
    !commandLineOptions.nocompress && transforms.compressJavaScript({type: 'JavaScript'}, 'uglifyJs', {toplevel: commandLineOptions.mangletoplevel}),
    localeIds && transforms.cloneForEachLocale({type: 'Html', isInitial: true}, localeIds),
    localeIds && transforms.runJavaScriptConditionalBlocks({isInitial: true}, 'localize', true),
    transforms.removeAssets({type: 'I18n'}, true),
    transforms.minifyAssets({type: ['Json', 'Html', 'JavaScript', 'Css']}),
    transforms.inlineRelations({
        type: ['HtmlStyle', 'HtmlScript'],
        from: {isInline: false}, // Excludes relations occurring in conditional comments
        to: function (asset) {return asset.isAsset && asset.rawSrc.length < 4096;}
    }),
    commandLineOptions.manifest && transforms.addCacheManifest({isInitial: true}),
    commandLineOptions.nocompress && transforms.prettyPrintAssets({type: ['Html', 'JavaScript', 'Css']}),
    transforms.setAsyncOrDeferOnHtmlScripts({to: {isInline: false, url: /^file:/}}, commandLineOptions.asyncscripts, commandLineOptions.deferscripts),
    transforms.omitGetStaticUrlFunctionCall(),
    transforms.moveAssetsInOrder({isInitial: query.not(true), type: query.not('CacheManifest')}, function (asset, assetGraph) {
        var targetUrl = "/static/";
        // Conservatively assume that all one.getStaticUrl relations pointing at non-images are intended to be fetched via XHR
        // and thus cannot be put on a CDN because of same origin restrictions:
        if (cdnroot && (asset.isImage || assetGraph.findRelations({to: asset, type: 'StaticUrlMapEntry'}).length === 0)) {
            targetUrl = cdnroot;
        }
        return targetUrl + asset.md5Hex.substr(0, 10) + asset.extension;

    }),
    transforms.parallel(
        transforms.writeAssetsToDisc({url: /^file:/}, outroot),
        cdnroot && transforms.writeAssetsToDisc({url: query.createPrefixMatcher(cdnroot)}, cdnoutroot || outroot, cdnroot)
    ),
    transforms.stats()
).run();
