#!/usr/bin/env node

var path = require('path'),
    fs = require('fs'),
    _ = require('underscore'),
    AssetGraph = require('assetgraph'),
    transforms = require('../lib/transforms'),
    i18nTools = require('../lib/util/i18nTools'),
    uglifyAst = require('assetgraph/lib/util/uglifyAst'),
    urlTools = require('assetgraph/lib/util/urlTools'),
    mkpathSync = require('../lib/util/mkpathSync'),
    commandLineOptions = require('optimist')
        .usage('$0 [--label <labelName>=<dir> ...] --babeldir=<dirForBabelFiles> --root <inputRootDirectory> --locale <localeId>,... <htmlFile>...')
        .demand(['root', 'locale', 'babeldir'])
        .argv,
    localeIds = _.flatten(_.flatten([commandLineOptions.locale]).map(function (localeId) {return localeId.split(",");}));

mkpathSync(commandLineOptions.babeldir);

new AssetGraph({root: commandLineOptions.root}).on('afterTransform', function (transform, elapsedTime) {
    console.log((elapsedTime / 1000).toFixed(3) + " secs: " + transform.name);
}).on('error', function (err) {
    console.error(err.stack);
    process.exit(1);
}).queue(
    transforms.registerLabelsAsCustomProtocols(commandLineOptions.label),
    transforms.loadAssets(commandLineOptions._.map(urlTools.fsFilePathToFileUrl)),
    transforms.populate({followRelations: {type: ['HtmlScript', 'JavaScriptOneInclude'], to: {url: AssetGraph.query.not(/^https?:/)}}}),
    function (assetGraph) {
        var initialHtmlAssets = assetGraph.findAssets({type: 'Html', isInitial: true}),
            oneTrOccurrencesByKey = i18nTools.findOneTrOccurrences(assetGraph, initialHtmlAssets),
            allKeys = i18nTools.extractAllReachableKeys(assetGraph, initialHtmlAssets);
        localeIds.forEach(function (localeId) {
            var babelSrc = '';
            _.each(oneTrOccurrencesByKey, function (occurrences, key) {
                if (key in allKeys && localeId in allKeys[key] && allKeys[key][localeId] !== null) {
                    var value = allKeys[key][localeId],
                        path = [];
                    (function serialize (obj) {
                        if (_.isArray(obj)) {
                            for (var i = 0 ; i < obj.length ; i += 1) {
                                path.push(i);
                                serialize(obj[i]);
                                path.pop();
                            }
                        } else if (typeof obj === 'object' && obj !== null) {
                            for (var propertyName in obj) {
                                path.push(propertyName);
                                serialize(obj[propertyName]);
                                path.pop();
                            }
                        } else {
                            // Assume a type that can be stringified using String(obj):
                            babelSrc += key + path.map(function (pathComponent) {
                                return '[' + pathComponent + ']';
                            }).join("") + "=" + String(obj).replace(/\\/g, "\\\\").replace(/\n/g, "\\n") + "\n";
                        }
                    }(value));
                }
            });
            var targetBabelFileName = path.resolve(commandLineOptions.babeldir, localeId + '.txt');
            if (babelSrc.length) {
                console.warn("Writing " + targetBabelFileName);
                fs.writeFileSync(targetBabelFileName, babelSrc, 'utf-8');
            } else {
                console.warn("No existing keys for " + localeId + ", not writing " + targetBabelFileName);
            }
        });
    }
).run();
